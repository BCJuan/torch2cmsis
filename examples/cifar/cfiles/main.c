#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h> 
#include "arm_math.h"
#include "arm_nnfunctions.h"
#include "parameters.h"
#include "weights.h"

/*
Example of code generated by hand for an square input image,
using only convolutions and fully connected layers and 
8 bit quantization of CMSIS legacy
*/

q7_t conv1_out[CONV1_OUT_CH*CONV1_OUT_DIM*CONV1_OUT_DIM];
q7_t pool1_out[CONV1_OUT_CH*POOL1_OUT_DIM*POOL1_OUT_DIM];
q7_t conv2_out[CONV2_OUT_CH*CONV2_OUT_DIM*CONV2_OUT_DIM];
q7_t pool2_out[CONV2_OUT_CH*POOL2_OUT_DIM*POOL2_OUT_DIM];
q7_t conv3_out[CONV3_OUT_CH*CONV3_OUT_DIM*CONV3_OUT_DIM];
q7_t pool3_out[CONV3_OUT_CH*POOL3_OUT_DIM*POOL3_OUT_DIM];
q7_t fc1_out[INTERFACE_OUT];
q7_t y_out[INTERFACE_OUT];

q7_t conv1_w[CONV1_WT_SHAPE] = CONV1_WT;
q7_t conv1_b[CONV1_BIAS_SHAPE] = CONV1_BIAS;
q7_t conv2_w[CONV2_WT_SHAPE] =  CONV2_WT;
q7_t conv2_b[CONV2_BIAS_SHAPE] = CONV2_BIAS;
q7_t conv3_w[CONV3_WT_SHAPE] =  CONV3_WT;
q7_t conv3_b[CONV3_BIAS_SHAPE] = CONV3_BIAS;
q7_t fc1_w[INTERFACE_WT_SHAPE] = INTERFACE_WT;
q7_t fc1_b[INTERFACE_BIAS_SHAPE] = INTERFACE_BIAS;

q7_t conv_buffer[MAX_CONV_BUFFER_SIZE];
q7_t fc_buffer[MAX_FC_BUFFER];

q7_t* load(const char* file)
{
	size_t sz;
	q7_t* in;
	FILE* fp = fopen(file,"rb");
	assert(fp);
	fseek(fp, 0, SEEK_END);
	sz = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	in = malloc(sz);
	fread(in, 1, sz, fp);
	fclose(fp);
	return in;
}

void save(const char* file, q7_t* out, size_t sz)
{
	FILE* fp = fopen(file,"wb");
	fwrite(out, 1, sz, fp);
	fclose(fp);
}

uint32_t network(q7_t* input)
{
	arm_convolve_HWC_q7_RGB(input, CONV1_IM_DIM, CONV1_IM_CH, conv1_w, CONV1_OUT_CH, CONV1_KER_DIM, CONV1_PADDING,
						  CONV1_STRIDE, conv1_b, CONV1_BIAS_LSHIFT, CONV1_OUT_RSHIFT, conv1_out, CONV1_OUT_DIM,
						  (q15_t *) conv_buffer, NULL);

	save("logs/conv1_out.raw", conv1_out, sizeof(conv1_out));
    arm_maxpool_q7_HWC(conv1_out, POOL1_IM_DIM, POOL1_IM_CH, POOL1_KER_DIM, POOL1_PADDING, POOL1_STRIDE, POOL1_OUT_DIM, conv_buffer, pool1_out);
    arm_relu_q7(pool1_out, POOL1_OUT_DIM * POOL1_OUT_DIM * CONV1_OUT_CH);

    arm_convolve_HWC_q7_fast(pool1_out, CONV2_IM_DIM, CONV2_IM_CH, conv2_w, CONV2_OUT_CH, CONV2_KER_DIM,
						  CONV2_PADDING, CONV2_STRIDE, conv2_b, CONV2_BIAS_LSHIFT, CONV2_OUT_RSHIFT, conv2_out,
						  CONV2_OUT_DIM, (q15_t *) conv_buffer, NULL);
	save("logs/conv2_out.raw", conv2_out, sizeof(conv2_out));
    arm_avepool_q7_HWC(conv2_out, POOL2_IM_DIM, POOL2_IM_CH, POOL2_KER_DIM, POOL2_PADDING, POOL2_STRIDE, POOL2_OUT_DIM, conv_buffer, pool2_out);
    arm_relu_q7(pool2_out, POOL2_OUT_DIM * POOL2_OUT_DIM * CONV2_OUT_CH);

	arm_convolve_HWC_q7_fast(pool2_out, CONV3_IM_DIM, CONV3_IM_CH, conv3_w, CONV3_OUT_CH, CONV3_KER_DIM,
						  CONV3_PADDING, CONV3_STRIDE, conv3_b, CONV3_BIAS_LSHIFT, CONV3_OUT_RSHIFT, conv3_out,
						  CONV3_OUT_DIM, (q15_t *) conv_buffer, NULL);
	save("logs/conv3_out.raw", conv3_out, sizeof(conv3_out));
	arm_avepool_q7_HWC(conv3_out, POOL3_IM_DIM, POOL3_IM_CH, POOL3_KER_DIM, POOL3_PADDING, POOL3_STRIDE, POOL3_OUT_DIM, conv_buffer, pool3_out);
	arm_relu_q7(pool3_out, POOL3_OUT_DIM * POOL3_OUT_DIM * CONV3_OUT_CH);

	arm_fully_connected_q7_opt(pool3_out, fc1_w, INTERFACE_DIM, INTERFACE_OUT, INTERFACE_BIAS_LSHIFT, INTERFACE_OUT_RSHIFT, fc1_b,
						  fc1_out, (q15_t *) fc_buffer);
	save("logs/interface_out.raw", fc1_out, sizeof(fc1_out));
    
    arm_softmax_q7(fc1_out, INTERFACE_OUT, y_out);
	save("logs/y_out.raw", y_out, sizeof(y_out));

	uint32_t index[1];
	q7_t result[1];
	uint32_t blockSize = sizeof(y_out);

	arm_max_q7(y_out, blockSize, result, index);
	//printf("Classified class %i\n", index[0]);

	return index[0];
}

int main(int argc, char** argv)
{
	q7_t *input;
    input = load("logs/input.raw");
    uint32_t index;
    index = network(input);
	return 0;
}